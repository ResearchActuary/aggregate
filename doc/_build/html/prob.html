<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>Probability and Risk Theory &mdash; aggregate 0.6.1 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="_static/css/spc-extend.css">
    <link rel="stylesheet" href="_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.6.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="genindex.html" >
    <link rel="search" title="Search" href="search.html" >
    <link rel="top" title="aggregate 0.6.1 documentation" href="index.html" >
    <link rel="next" title="Frequency Distributions" href="freq_dist.html" >
    <link rel="prev" title="Tutorial" href="tutorial.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="index.html">
      <img style="border: 0;" alt="SciPy" src="_static/img/scipy_org_logo.gif"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="http://SOMETHING/">agg?</a></li>
        <li class="active"><a href="http://www.mynl.com/aggregate/index.html">agg Docs</a></li>
	
        <li class="active"><a href="index.html">aggregate 0.6.1 documentation</a></li>
	 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="freq_dist.html" title="Frequency Distributions"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="tutorial.html" title="Tutorial"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="probability-and-risk-theory">
<span id="probability-and-risk-theory"></span><h1>Probability and Risk Theory<a class="headerlink" href="#probability-and-risk-theory" title="Permalink to this headline">¶</a></h1>
<div class="section" id="discretizing-severity-distributions">
<span id="discretizing-severity-distributions"></span><h2>Discretizing Severity Distributions<a class="headerlink" href="#discretizing-severity-distributions" title="Permalink to this headline">¶</a></h2>
<p>There are two simple ways to discretize a continuous distribution.</p>
<ol>
<li><p class="first">Approximate the distribution with a purely discrete distribution supported at points $x_k=x_0+kb$,
$k=0,1,\dots, N$. Call $b$ the bucket size. The discrete probabilities are
$p_k=P(x_k - b/2 &lt; X \le x_k+b/2)$. To create a rv_histogram variable from <code class="docutils literal"><span class="pre">xs</span></code> and corresponding
<code class="docutils literal"><span class="pre">p</span></code> values use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span> <span class="n">xss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">xs</span><span class="p">,</span> <span class="n">xs</span> <span class="o">+</span> <span class="mf">1e-5</span><span class="p">)))</span>
 <span class="n">pss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ps1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ps1</span><span class="p">)))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
 <span class="n">fz_discr</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">rv_histogram</span><span class="p">((</span><span class="n">pss</span><span class="p">,</span> <span class="n">xss</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ol>
<p>The value 1e-5 just needs to be smaller than the resolution requested, i.e. do not &quot;split the bucket&quot;.
Generally histograms will be downsampled, not upsampled, so this is not a restriction.</p>
<ol>
<li><p class="first">Approximate the distribution with a continuous &quot;histogram&quot; distribution
that is uniform on $(x_k, x_{k+1}]$. The discrete proababilities are $p_k=P(x_k &lt; X \le x_{k+1})$.
To create a rv_histogram variable is much easier, just use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span> <span class="n">xs2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">xs</span><span class="p">,</span> <span class="n">xs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
 <span class="n">fz_cts</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">rv_histogram</span><span class="p">((</span><span class="n">ps2</span><span class="p">,</span> <span class="n">xs2</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ol>
<p>The first method we call <strong>discrete</strong> and the second <strong>histogram</strong>. The discrete method is appropriate
when the distribution will be used and interpreted as fully discrete, which is the assumption the FFT
method makes. The histogram method is useful if the distribution will be used to create a scipy.stats
rv_histogram variable. If the historgram method is interpreted as discrete and if the mean is computed
appropriately for a discrete variable as $\sum_i p_k x_k$, then the mean will be under-estimated by $b/2$.</p>
</div>
<div class="section" id="generalized-distributions">
<span id="generalized-distributions"></span><h2>Generalized Distributions<a class="headerlink" href="#generalized-distributions" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="fast-fourier-transforms">
<span id="fast-fourier-transforms"></span><h2>Fast Fourier Transforms<a class="headerlink" href="#fast-fourier-transforms" title="Permalink to this headline">¶</a></h2>
<p>The FFT method is a miraculous technique for computing aggregate
distributions. It is especially effective when the expected claim count
is relatively small and the underlying severity distribution is bounded.
These assumptions are true for many excess of loss reinsurance treaties,
for example. Thus the FFT is very useful when quoting excess layers with
annual aggregate deductibles or other variable features. The FFT
provides a discrete approximation to the moment generating function.</p>
<p>To use the FFT method, first &quot;bucket&quot; (or quantize) the severity
distribution into a density vector $\bm{x}=(x_1,\dots,x_{m})$ whose length
$m$ is a power of two $m=2^n$. Here $$\begin{gathered}
x_i= \text{Pr}((i-1/2)b&lt;X&lt;(i+1/2)b)\ x_1=\text{Pr}(X&lt;b/2),\quad x_{m}=\text{Pr}(X&gt;(m-1/2)b)\end{gathered}$$
for some fixed $b$. We call $b$ the bucket size. Note $\sum_i
x_i=1$ by construction. The FFT of the $m\times 1$ vector $\bm{x}$ is
another $m\times 1$ vector $\hat\bm{x}$ whose $j$th component is
$$
\sum_{k=0}^{2^n-1} x_k\exp(2\pi ijk/2^n).\label{fft}
$$
The
coefficients of $\hat\bm{x}$ are complex numbers. It is also possible to
express $\hat\bm{x}=\F\bm{x}$ where $\F$ is an appropriate matrix of complex
roots of unity, so there is nothing inherently mysterious about a FFT.
The trick is that there exists a very efficient algorithm for computing
(<a class="reference external" href="#fft">[fft]</a>{reference-type=&quot;ref&quot; reference=&quot;fft&quot;}). Rather than
taking time proportional to $m^2$, as one would expect, it can be
computed in time proportional to $m\log(m)$. The difference between
$m\log(m)$ and $m^2$ time is the difference between practically possible
and practically impossible.</p>
<p>You can use the inverse FFT to recover $\bm{x}$ from its transform $\hat\bm{x}$.
The inverse FFT is computed using the same equation
(<a class="reference external" href="#fft">[fft]</a>{reference-type=&quot;ref&quot; reference=&quot;fft&quot;}) as the FFT
except there is a minus sign in the exponent and the result is divided
by $2^n$. Because the equation is essentially the same, the inversion
process can also be computed in $m\log(m)$ time.</p>
<p>The next step is magic in actuarial science. Remember that if $N$ is a
$G$-mixed Poisson and $A=X_1+\cdots+X_N$ is an aggregate distribution
then
$$
M_A(\zeta)=M_G(n(M_X(\zeta)-1)).
$$
Using FFTs you can replace the <em>function</em> $M_X$ with the discrete approximation <em>vector</em> $\hat\bm{x}$ and
compute
$$
\hat\a=M_G(n(\hat\bm{x} -1))
$$
component-by-component to get an
approximation vector to the function $M_A$. You can then use the inverse
FFT to recover an discrete approximation $\a$ of $A$ from $\hat\a$! See
Wang [&#64;bigWang] for more details.</p>
<p>Similar tricks are possible in two dimensions---see Press et al. [&#64;nrc]
and Homer and Clark [&#64;homerclark] for a discussion.</p>
<p>The FFT allows us to use the following very simple method to
qualitatively approximate the density of an aggregate of dependent
marginals $X_1,\dots,X_n$ given a correlation matrix $\Sigma$. First use
the FFT method to compute the sum $S'$ of the $X_i$ as though they were
independent. Let $\text{Var}(S')=\sigma^{'2}$ and let $\sigma^2$ be the
variance of the sum of the $X_i$ implied by $\Sigma$. Next use the FFT
to add a further &quot;noise&quot; random variable $N$ to $S'$ with mean zero and
variance $\sigma^2-\sigma^{'2}$. Two obvious choices for the
distribution of $N$ are normal or shifted lognormal. Then $S'+N$ has the
same mean and variance as the sum of the dependent variables $X_i$. The
range of possible choices for $N$ highlights once again that knowing the
marginals and correlation structure is not enough to determine the whole
multivariate distribution. It is an interesting question whether all
possible choices of $N$ correspond to actual multivariate structures for
the $X_i$ and conversely whether all multivariate structures correspond
to an $N$. (It is easy to use MGFs to deconvolve $N$ from the true sum
using Fourier methods; the question is whether the resulting
&quot;distribution&quot; is non-negative.)</p>
<p>Heckman and Meyers [&#64;heckmeyers] used Fourier transforms to compute
aggregate distributions by numerically integrating the characteristic
function. Direct inversion of the Fourier transform is also possible
using FFTs. The application of FFTs is not completely straight forward
because of certain aspects of the approximations involved. The details
are very clearly explained in Menn and Rachev [&#64;mennrachev]. Their
method allows the use of FFTs to determine densities for distributions
which have analytic MGFs but not densities---notably the class of stable
distributions.</p>
</div>
</div>


          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Probability and Risk Theory</a><ul>
<li><a class="reference internal" href="#discretizing-severity-distributions">Discretizing Severity Distributions</a></li>
<li><a class="reference internal" href="#generalized-distributions">Generalized Distributions</a></li>
<li><a class="reference internal" href="#fast-fourier-transforms">Fast Fourier Transforms</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tutorial.html"
                        title="previous chapter">Tutorial</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="freq_dist.html"
                        title="next chapter">Frequency Distributions</a></p>
  <h3>This Page</h3>
  <div>
    <a href="_sources/prob.md.txt"
       rel="nofollow">Show Source</a>
  </div>
<div class="this-page-menu">
  <a href="/scipy/docs/scipy-docs/prob.md.rst">Edit page</a>
</div>

        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2018, Stephen J. Mildenhall.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.3.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>