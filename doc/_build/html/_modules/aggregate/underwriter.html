<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>aggregate.underwriter &mdash; aggregate 0.7.1 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="../../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../None"></script>
    <script type="text/javascript" src="../../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" >
    <link rel="search" title="Search" href="../../search.html" >
    <link rel="top" title="aggregate 0.7.1 documentation" href="../../index.html" >
    <link rel="up" title="Module code" href="../index.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="../../index.html">
      <img style="border: 0;" alt="SciPy" src="../../_static/img/scipy_org_logo.gif"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="https://github.com/mynl/aggregate">aggregate Code</a></li>
	
        <li class="active"><a href="../../index.html">aggregate 0.7.1 documentation</a></li>
	
          <li class="active"><a href="../index.html" accesskey="U">Module code</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <h1>Source code for aggregate.underwriter</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">=================</span>
<span class="sd">Underwriter Class</span>
<span class="sd">=================</span>

<span class="sd">The Underwriter is an easy to use interface into the computational functionality of aggregate.</span>

<span class="sd">The Underwriter</span>
<span class="sd">---------------</span>

<span class="sd">* Maintains a default library of severity curves</span>
<span class="sd">* Maintains a default library of aggregate distributions corresponding to industry losses in</span>
<span class="sd">  major classes of business, total catastrophe losses from major perils, and other useful constructs</span>
<span class="sd">* Maintains a default library of portfolios, including several example instances and examples used in</span>
<span class="sd">  papers on risk theory (e.g. the Bodoff examples)</span>


<span class="sd">The library functions can be listed using</span>

<span class="sd">::</span>

<span class="sd">        uw.list()</span>

<span class="sd">or, for more detail</span>

<span class="sd">::</span>

<span class="sd">        uw.describe()</span>

<span class="sd">A given example can be inspected using ``uw[&#39;cmp&#39;]`` which returns the defintion of the database</span>
<span class="sd">object cmp (an aggregate representing industry losses from the line Commercial Multiperil). It can</span>
<span class="sd">be created as an Aggregate class using ``ag = uw(&#39;cmp&#39;)``. The Aggregate class can then be updated,</span>
<span class="sd">plotted and various reports run on it. In iPython or Jupyter ``ag`` returns an informative HTML</span>
<span class="sd">description.</span>

<span class="sd">The real power of Underwriter is access to the agg scripting language (see parser module). The scripting</span>
<span class="sd">language allows severities, aggregates and portfolios to be created using more-or-less natural language.</span>
<span class="sd">For example</span>

<span class="sd">::</span>

<span class="sd">        pf = uw(&#39;&#39;&#39;</span>
<span class="sd">        port MyCompanyBook</span>
<span class="sd">            agg LineA 100 claims 100000 xs 0 sev lognorm 30000 cv 1.25</span>
<span class="sd">            agg LineB 150 claims 250000 xs 5000 sev lognorm 50000 cv 0.9</span>
<span class="sd">            agg Cat 2 claims 100000000 xs 0 sev 500000 * pareto 1.8 - 500000</span>
<span class="sd">        &#39;&#39;&#39;)</span>

<span class="sd">creates a portfolio with three sublines, LineA, LineB and Cat. LineA is 100 (expected) claims, each pulled</span>
<span class="sd">from a lognormal distribution with mean of 30000 and coefficient of variation 1.25 within the layer</span>
<span class="sd">100000 xs 0 (i.e. limited at 100000). The frequency distribution is Poisson. LineB is similar. Cat is jsut</span>
<span class="sd">2 claims from the indicated limit, with severity given by a Pareto distribution with shape parameter 1.8,</span>
<span class="sd">scale 500000, shifted left by 500000. This corresponds to the usual Pareto with survival function</span>
<span class="sd">S(x) = (lambda / (lambda + x))^1.8, x &gt;= 0.</span>

<span class="sd">The portfolio can be approximated using FFTs to convolve the aggregates and add the lines. The severities</span>
<span class="sd">are first discretized using a certain bucket-size (bs). The port object has a port.recommend_bucket() to</span>
<span class="sd">suggest reasonable buckets:</span>

<span class="sd">&gt;&gt; pf.recommend_bucket()</span>

<span class="sd">+-------+---------+--------+--------+--------+-------+-------+-------+------+------+</span>
<span class="sd">|       | bs10    | bs11   | bs12   | bs13   | bs14  | bs15  | bs16  | bs18 | bs20 |</span>
<span class="sd">+=======+=========+========+========+========+=======+=======+=======+======+======+</span>
<span class="sd">| LineA | 3,903   | 1,951  | 976    | 488    | 244   | 122   | 61.0  | 15.2 | 3.8  |</span>
<span class="sd">+-------+---------+--------+--------+--------+-------+-------+-------+------+------+</span>
<span class="sd">| LineB | 8,983   | 4,491  | 2,245  | 1,122  | 561   | 280   | 140   | 35.1 | 8.8  |</span>
<span class="sd">+-------+---------+--------+--------+--------+-------+-------+-------+------+------+</span>
<span class="sd">| Cat   | 97,656  | 48,828 | 24,414 | 12,207 | 6,103 | 3,051 | 1,525 | 381  | 95.4 |</span>
<span class="sd">+-------+---------+--------+--------+--------+-------+-------+-------+------+------+</span>
<span class="sd">| total | 110,543 | 55,271 | 27,635 | 13,817 | 6,908 | 3,454 | 1,727 | 431  | 108  |</span>
<span class="sd">+-------+---------+--------+--------+--------+-------+-------+-------+------+------+</span>

<span class="sd">The column bsNcorrespond to discretizing with 2**N buckets. The rows show suggested bucket sizes for each</span>
<span class="sd">line and in total. For example with N=13 (i.e. 8196 buckets) the suggestion is 13817. It is best the bucket</span>
<span class="sd">size is a divisor of any limits or attachment points, so we select 10000.</span>

<span class="sd">Updating can then be run as</span>

<span class="sd">::</span>

<span class="sd">    bs = 10000</span>
<span class="sd">    pf.update(13, bs)</span>
<span class="sd">    pf.report(&#39;quick&#39;)</span>
<span class="sd">    pf.plot(&#39;density&#39;)</span>
<span class="sd">    pf.plot(&#39;density&#39;, logy=True)</span>
<span class="sd">    print(pf)</span>

<span class="sd">    Portfolio name           MyCompanyBook</span>
<span class="sd">    Theoretic expected loss     10,684,541.2</span>
<span class="sd">    Actual expected loss        10,657,381.1</span>
<span class="sd">    Error                          -0.002542</span>
<span class="sd">    Discretization size                   13</span>
<span class="sd">    Bucket size                     10000.00</span>
<span class="sd">    &lt;aggregate.port.Portfolio object at 0x0000023950683CF8&gt;</span>


<span class="sd">Etc. etc.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">IPython.core.display</span> <span class="k">import</span> <span class="n">display</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">.port</span> <span class="k">import</span> <span class="n">Portfolio</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">html_title</span>
<span class="kn">from</span> <span class="nn">.distr</span> <span class="k">import</span> <span class="n">Aggregate</span><span class="p">,</span> <span class="n">Severity</span>
<span class="kn">from</span> <span class="nn">.parser</span> <span class="k">import</span> <span class="n">UnderwritingLexer</span><span class="p">,</span> <span class="n">UnderwritingParser</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>


<div class="viewcode-block" id="Underwriter"><a class="viewcode-back" href="../../underwriter.html#aggregate.underwriter.Underwriter">[docs]</a><span class="k">class</span> <span class="nc">Underwriter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The underwriter class constructs real world examples from stored and user input Lines and Accounts.</span>
<span class="sd">    Whereas Examples only produces simple Portfolios and Books, the Underwriter class is more flexible.</span>

<span class="sd">    Handles persistence</span>
<span class="sd">    Is interface into program parser</span>
<span class="sd">    Handles safe lookup from database for parser</span>

<span class="sd">    Persisitence to and from agg files</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data_types</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;portfolio&#39;</span><span class="p">,</span> <span class="s1">&#39;aggregate&#39;</span><span class="p">,</span> <span class="s1">&#39;severity&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dir_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Rory&#39;</span><span class="p">,</span> <span class="n">databases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">glob</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">store_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">log2</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">create_all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param dir_name:</span>
<span class="sd">        :param name:</span>
<span class="sd">        :param databases:</span>
<span class="sd">        :param glob: reference, e.g. to globals(), used to resolve meta.XX references</span>
<span class="sd">        :param store_mode: add newly created aggregates to the database?</span>
<span class="sd">        :param update:</span>
<span class="sd">        :param verbose:</span>
<span class="sd">        :param log2:</span>
<span class="sd">        :param debug: run parser in debug mode</span>
<span class="sd">        :param create_all: by default write only creates portfolios.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">last_spec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span> <span class="o">=</span> <span class="n">update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log2</span> <span class="o">=</span> <span class="n">log2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>  <span class="c1"># for update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">glob</span> <span class="o">=</span> <span class="n">glob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span> <span class="o">=</span> <span class="n">UnderwritingLexer</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parser</span> <span class="o">=</span> <span class="n">UnderwritingParser</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_safe_lookup</span><span class="p">,</span> <span class="n">debug</span><span class="p">)</span>
        <span class="c1"># otherwise these are hidden from pyCharm....</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">severity</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aggregate</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">portfolio</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">databases</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">databases</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;site.agg&#39;</span><span class="p">,</span> <span class="s1">&#39;user.agg&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dir_name</span> <span class="o">=</span> <span class="n">dir_name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dir_name</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dir_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dir_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dir_name</span><span class="p">,</span> <span class="s1">&#39;agg&#39;</span><span class="p">)</span>
        <span class="c1"># make sure all database entries are stored:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_mode</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">databases</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dir_name</span><span class="p">,</span> <span class="n">fn</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">program</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="c1"># read in, parse, save to sev/agg/port dictionaries</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_runner</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
        <span class="c1"># set desired store_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_mode</span> <span class="o">=</span> <span class="n">store_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_all</span> <span class="o">=</span> <span class="n">create_all</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        handles self[item]</span>

<span class="sd">        subscriptable: try user portfolios, b/in portfolios, line, severity</span>
<span class="sd">        to access specifically use severity or line methods</span>

<span class="sd">        :param item:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># much less fancy version:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">portfolio</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Underwriter.__getitem__ | found </span><span class="si">{item}</span><span class="s1"> of type port&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="s1">&#39;port&#39;</span><span class="p">,</span> <span class="n">obj</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Underwriter.__getitem__ | found </span><span class="si">{item}</span><span class="s1"> of type agg&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="s1">&#39;agg&#39;</span><span class="p">,</span> <span class="n">obj</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">severity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Underwriter.__getitem__ | found </span><span class="si">{item}</span><span class="s1"> of type sev&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="s1">&#39;sev&#39;</span><span class="p">,</span> <span class="n">obj</span>
        <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Item </span><span class="si">{item}</span><span class="s1"> not found in any database&#39;</span><span class="p">)</span>
        <span class="c1"># old, clever, generic, unreadable, unnecessary generality</span>
        <span class="c1"># for k in self.databases.keys():</span>
        <span class="c1">#     if item in self.__getattribute__(k).keys():</span>
        <span class="c1">#         # stip the s off the name: Books to Book etc.</span>
        <span class="c1">#         return k, self.__getattribute__(k)[item]</span>
        <span class="c1"># raise LookupError</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="s1">&#39;&lt;h1&gt;Underwriter </span><span class="si">{self.name}</span><span class="s1">&lt;/h1&gt;&#39;</span><span class="p">]</span>
        <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Underwriter expert in all classes including {len(self.severity)} severities, {len(self.aggregate)} aggregates&#39;</span>
                 <span class="n">f</span><span class="s1">&#39; and {len(self.portfolio)} portfolios&lt;br&gt;&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">what</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;severity&#39;</span><span class="p">,</span> <span class="s1">&#39;aggregate&#39;</span><span class="p">,</span> <span class="s1">&#39;portfolio&#39;</span><span class="p">]:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;&lt;b&gt;{what.title()}&lt;/b&gt;: &#39;</span><span class="p">)</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">())]))</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&lt;br&gt;&#39;</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;&lt;h3&gt;Settings&lt;/h3&gt;&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;update&#39;</span><span class="p">,</span> <span class="s1">&#39;log2&#39;</span><span class="p">,</span> <span class="s1">&#39;store_mode&#39;</span><span class="p">,</span> <span class="s1">&#39;verbose&#39;</span><span class="p">,</span> <span class="s1">&#39;last_spec&#39;</span><span class="p">,</span> <span class="s1">&#39;create_all&#39;</span><span class="p">]:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;&lt;span style=&quot;color: red;&quot;&gt;</span><span class="si">{k}</span><span class="s1">&lt;/span&gt;: {getattr(self, k)}; &#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="c1"># this is evil: it passes unknown things through to write...</span>
    <span class="c1"># def __getattr__(self, item):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     handles self.item and returns an appropriate object</span>
    <span class="c1">#</span>
    <span class="c1">#     :param item:</span>
    <span class="c1">#     :return:</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     # print(f&#39;Underwriter.__getattr__({item}) called&#39;)</span>
    <span class="c1">#     if item[0] == &#39;_&#39;:</span>
    <span class="c1">#         # deal with the _ipython_canary_method_should_not_exist_</span>
    <span class="c1">#         # print(&#39;bailing&#39;)</span>
    <span class="c1">#         return</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         return self.write(item)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">portfolio_program</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        make the Underwriter object callable; pass through to write</span>

<span class="sd">        :param portfolio_program:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">portfolio_program</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Underwriter.list"><a class="viewcode-back" href="../../underwriter.html#aggregate.underwriter.Underwriter.list">[docs]</a>    <span class="k">def</span> <span class="nf">list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        list all available databases</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sers</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Underwriter</span><span class="o">.</span><span class="n">data_types</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="n">sers</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">title</span><span class="p">()]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)),</span> <span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">sers</span><span class="p">)</span>
        <span class="c1"># df.index.name = &#39;No.&#39;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="Underwriter.describe"><a class="viewcode-back" href="../../underwriter.html#aggregate.underwriter.Underwriter.describe">[docs]</a>    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item_type</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        more informative version of list</span>
<span class="sd">        Pull notes for type items</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">deal_with_sequences</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            pandas can&#39;t have a field set as a sequence</span>
<span class="sd">            need to check if x is a sequence and if so return something suitable...</span>

<span class="sd">            :param x:</span>
<span class="sd">            :return:</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Name&#39;</span><span class="p">,</span> <span class="s1">&#39;Type&#39;</span><span class="p">,</span> <span class="s1">&#39;Severity&#39;</span><span class="p">,</span> <span class="s1">&#39;ESev&#39;</span><span class="p">,</span> <span class="s1">&#39;Sev_a&#39;</span><span class="p">,</span> <span class="s1">&#39;Sev_b&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;EN&#39;</span><span class="p">,</span> <span class="s1">&#39;Freq_a&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;ELoss&#39;</span><span class="p">,</span> <span class="s1">&#39;Notes&#39;</span><span class="p">])</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;Name&#39;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;ELoss&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">ELoss</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">ESev</span> <span class="o">*</span> <span class="n">df</span><span class="o">.</span><span class="n">EN</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">item_type</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">item_type</span> <span class="o">=</span> <span class="n">Underwriter</span><span class="o">.</span><span class="n">data_types</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">item_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">item_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">item_type</span><span class="p">:</span>  <span class="c1"># self.databases.keys():</span>
            <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">_data_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">vv</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sev_name&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="n">vv</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sev_mean&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">vv</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sev_a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                <span class="n">vv</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sev_b&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">vv</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;exp_en&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">vv</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;freq_a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                <span class="n">vv</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;exp_el&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">vv</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;note&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">_data_fields</span>
                <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;setting an array element with a sequence&quot;</span><span class="p">:</span>
                        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">deal_with_sequences</span><span class="p">,</span> <span class="n">_data_fields</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">e</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pretty_print</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">egs</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;Type&#39;</span><span class="p">):</span>
                <span class="n">html_title</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">display</span><span class="p">(</span><span class="n">egs</span><span class="o">.</span><span class="n">style</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="Underwriter.parse_portfolio_program"><a class="viewcode-back" href="../../underwriter.html#aggregate.underwriter.Underwriter.parse_portfolio_program">[docs]</a>    <span class="k">def</span> <span class="nf">parse_portfolio_program</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">portfolio_program</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility routine to parse the program and return the spec suitable to pass to Portfolio to</span>
<span class="sd">        create the object.</span>
<span class="sd">        Initially just for a single portfolio program (which it checks!)</span>
<span class="sd">        No argument of default conniptions</span>

<span class="sd">        TODO: seems like overlaps with write_test</span>

<span class="sd">        TODO make more robust</span>
<span class="sd">        :param portfolio_program:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_runner</span><span class="p">(</span><span class="n">portfolio_program</span><span class="p">)</span>

        <span class="c1"># if globs replace all meta objects with a lookup object</span>
        <span class="c1"># copy from code below FRAGILE</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">glob</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">agg_out_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">sev_out_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="s1">&#39;sev_name&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;meta&#39;</span><span class="p">:</span>
                    <span class="n">obj_name</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="s1">&#39;sev_name&#39;</span><span class="p">][</span><span class="mi">5</span><span class="p">:]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">glob</span><span class="p">[</span><span class="n">obj_name</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">NameError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Object </span><span class="si">{obj_name}</span><span class="s1"> passed as a proto-severity cannot be found&#39;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="n">e</span>
                    <span class="n">a</span><span class="p">[</span><span class="s1">&#39;sev_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Underwriter.write | </span><span class="si">{a[&quot;sev_name&quot;]}</span><span class="s1"> ({type(a)} reference to </span><span class="si">{obj_name}</span><span class="s1"> &#39;</span>
                                 <span class="n">f</span><span class="s1">&#39;replaced with object </span><span class="si">{obj.name}</span><span class="s1"> from glob&#39;</span><span class="p">)</span>

        <span class="c1"># expecting a single portfolio for this simple function</span>
        <span class="c1"># create the spec list string</span>
        <span class="n">nm</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">spec_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">port_out_dict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">port_out_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">nm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">port_out_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># remember the spec comes back as a list of aggs that have been entered into the uw</span>
                <span class="n">spec_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">portfolio</span><span class="p">[</span><span class="n">nm</span><span class="p">][</span><span class="s1">&#39;spec&#39;</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">nm</span><span class="p">,</span> <span class="n">spec_list</span></div>

<div class="viewcode-block" id="Underwriter.write"><a class="viewcode-back" href="../../underwriter.html#aggregate.underwriter.Underwriter.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">portfolio_program</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write a natural language program. Write carries out the following steps.</span>

<span class="sd">        1. Read in the program and cleans it (e.g. punctuation, parens etc. are</span>
<span class="sd">        removed and ignored, replace ; with new line etc.)</span>
<span class="sd">        2. Parse line by line to create a dictioonary definition of sev, agg or port objects</span>
<span class="sd">        3. If glob set, pull in objects</span>
<span class="sd">        4. replace sev.name, agg.name and port.name references with their objects</span>
<span class="sd">        5. If create_all set, create all objects and return in dictionary. If not set only create the port objects</span>
<span class="sd">        6. If update set, update all created objects.</span>

<span class="sd">        Sample input</span>

<span class="sd">        ::</span>

<span class="sd">            port MY_PORTFOLIO</span>
<span class="sd">                agg Line1 20  loss 3 x 2 sev gamma 5 cv 0.30 mixed gamma 0.4</span>
<span class="sd">                agg Line2 10  claims 3 x 2 sevgamma 12 cv 0.30 mixed gamma 1.2</span>
<span class="sd">                agg Line 3100  premium at 0.4 3 x 2 sev 4 * lognormal 3 cv 0.8 fixed 1</span>

<span class="sd">        The indents are required...</span>

<span class="sd">        See parser for full language spec! See Aggregate class for many examples.</span>

<span class="sd">        Reasonable kwargs:</span>

<span class="sd">        * bs</span>
<span class="sd">        * log2</span>
<span class="sd">        * verbose</span>
<span class="sd">        * update overrides class default</span>
<span class="sd">        * add_exa should port.add_exa add the exa related columns to the output?</span>
<span class="sd">        * create_all: create all objects, default just portfolios. You generally</span>
<span class="sd">                     don&#39;t want to create underlying sevs and aggs in a portfolio.</span>

<span class="sd">        :param portfolio_program:</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">        :return: single created object or dictionary name: object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># prepare for update</span>
        <span class="c1"># what / how to do; little awkward: to make easier for user have to strip named update args</span>
        <span class="c1"># out of kwargs</span>
        <span class="n">create_all</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;create_all&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_all</span><span class="p">)</span>
        <span class="n">update</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;update&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;log2&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">log2</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;log2&#39;</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;log2&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log2</span>
            <span class="k">if</span> <span class="s1">&#39;bs&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">bs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bs&#39;</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;bs&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bs</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="s1">&#39;verbose&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;verbose&#39;</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span>
            <span class="k">if</span> <span class="s1">&#39;add_exa&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">add_exa</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;add_exa&#39;</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;add_exa&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">add_exa</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># function to handle update madness, use in either script or lookup updats for ports</span>
        <span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">bs</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">log2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">_bs</span> <span class="o">=</span> <span class="n">bs</span>
                    <span class="n">_log2</span> <span class="o">=</span> <span class="n">log2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">bs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># and log2 &gt; 0</span>
                        <span class="c1"># for log2 = 10</span>
                        <span class="n">_bs</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recommend_bucket</span><span class="p">()</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="n">_log2</span> <span class="o">=</span> <span class="n">log2</span>  <span class="c1"># which must be &gt; 0</span>
                        <span class="c1"># adjust bucket size for new actual log2</span>
                        <span class="n">_bs</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="mi">10</span> <span class="o">-</span> <span class="n">_log2</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># bs &gt; 0 and log2 = 0 which doesn&#39;t really make sense...</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Underwriter.write | nonsensical options bs &gt; 0 and log2 = 0&#39;</span><span class="p">)</span>
                        <span class="n">_bs</span> <span class="o">=</span> <span class="n">bs</span>
                        <span class="n">_log2</span> <span class="o">=</span> <span class="mi">10</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Underwriter.write | updating Portfolio </span><span class="si">{k}</span><span class="s2"> log2=</span><span class="si">{_log2}</span><span class="s2">, bs=</span><span class="si">{_bs}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">s</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">log2</span><span class="o">=</span><span class="n">_log2</span><span class="p">,</span> <span class="n">bs</span><span class="o">=</span><span class="n">_bs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">add_exa</span><span class="o">=</span><span class="n">add_exa</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># first see if it is a built in object</span>
        <span class="n">lookup_success</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">_type</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_type</span><span class="p">,</span> <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">portfolio_program</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">LookupError</span><span class="p">:</span>
            <span class="n">lookup_success</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;underwriter.write | object </span><span class="si">{portfolio_program[:500]}</span><span class="s1"> not found, will process as program&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lookup_success</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;underwriter.write | object </span><span class="si">{portfolio_program[:500]}</span><span class="s1"> found, returning object...&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_type</span> <span class="o">==</span> <span class="s1">&#39;agg&#39;</span><span class="p">:</span>
                <span class="c1"># TODO, sure this isn&#39;t the solution to the double name problem....</span>
                <span class="n">_name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">portfolio_program</span><span class="p">)</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">Aggregate</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;name&#39;</span><span class="p">})</span>
                <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">easy_update</span><span class="p">(</span><span class="n">log2</span><span class="p">,</span> <span class="n">bs</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">obj</span>
            <span class="k">elif</span> <span class="n">_type</span> <span class="o">==</span> <span class="s1">&#39;port&#39;</span><span class="p">:</span>
                <span class="c1"># actually make the object</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">Portfolio</span><span class="p">(</span><span class="n">portfolio_program</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;spec&#39;</span><span class="p">]])</span>
                <span class="n">_update</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">portfolio_program</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">obj</span>
            <span class="k">elif</span> <span class="n">_type</span> <span class="o">==</span> <span class="s1">&#39;sev&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;sev_wt&#39;</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;sev_wt&#39;</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">Severity</span><span class="p">(</span><span class="o">**</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Cannot build </span><span class="si">{_type}</span><span class="s1"> objects&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">obj</span>

        <span class="c1"># if you fall through to here then the portfolio_program did not refer to a built in object</span>
        <span class="c1"># run the program</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_runner</span><span class="p">(</span><span class="n">portfolio_program</span><span class="p">)</span>

        <span class="c1"># if globs replace all meta objects with a lookup object</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">glob</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Underwriter.write | Resolving globals&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">agg_out_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">sev_out_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="s1">&#39;sev_name&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;meta&#39;</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Underwriter.write | Resolving </span><span class="si">{a[&quot;sev_name&quot;]}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">obj_name</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="s1">&#39;sev_name&#39;</span><span class="p">][</span><span class="mi">5</span><span class="p">:]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">glob</span><span class="p">[</span><span class="n">obj_name</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">NameError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Object </span><span class="si">{obj_name}</span><span class="s1"> passed as a proto-severity cannot be found&#39;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="n">e</span>
                    <span class="n">a</span><span class="p">[</span><span class="s1">&#39;sev_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Underwriter.write | </span><span class="si">{a[&quot;sev_name&quot;]}</span><span class="s1"> ({type(a)} reference to </span><span class="si">{obj_name}</span><span class="s1"> &#39;</span>
                                 <span class="n">f</span><span class="s1">&#39;replaced with object </span><span class="si">{obj.name}</span><span class="s1"> from glob&#39;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Underwriter.write | Done resolving globals&#39;</span><span class="p">)</span>

        <span class="c1"># create objects</span>
        <span class="c1"># 2019-11: create all objects not just the portfolios if create_all==True</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">port_out_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># create ports</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">port_out_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># remember the spec comes back as a list of aggs that have been entered into the uw</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">Portfolio</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">portfolio</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;spec&#39;</span><span class="p">]])</span>
                <span class="n">_update</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                <span class="n">rv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">agg_out_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">create_all</span><span class="p">:</span>
            <span class="c1"># new aggs, create them</span>
            <span class="k">if</span> <span class="n">rv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">agg_out_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># TODO FIX this clusterfuck</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">Aggregate</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">kk</span><span class="p">:</span> <span class="n">vv</span> <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">vv</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">kk</span> <span class="o">!=</span> <span class="s1">&#39;name&#39;</span><span class="p">})</span>
                <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">easy_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                <span class="n">rv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">sev_out_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">create_all</span><span class="p">:</span>
            <span class="c1"># new sevs, create them</span>
            <span class="k">if</span> <span class="n">rv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">sev_out_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="s1">&#39;sev_wt&#39;</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;sev_wt&#39;</span><span class="p">]</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">Severity</span><span class="p">(</span><span class="o">**</span><span class="n">v</span><span class="p">)</span>
                <span class="n">rv</span><span class="p">[</span><span class="n">f</span><span class="s1">&#39;sev_{s.__repr__()[38:54]}&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>

        <span class="c1"># report on what has been done</span>
        <span class="k">if</span> <span class="n">rv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: Program did not contain any output...&#39;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Underwriter.write | Program </span><span class="si">{portfolio_program}</span><span class="s1"> did not contain any output&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rv</span><span class="p">):</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Underwriter.write | Program created {len(rv)} objects and &#39;</span> 
                     <span class="n">f</span><span class="s1">&#39;defined {len(self.parser.port_out_dict)} Portfolio(s), &#39;</span> 
                     <span class="n">f</span><span class="s1">&#39;{len(self.parser.agg_out_dict)} Aggregate(s), and &#39;</span>
                     <span class="n">f</span><span class="s1">&#39;{len(self.parser.sev_out_dict)} Severity(ies)&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="n">rv</span><span class="o">.</span><span class="n">popitem</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># return created objects</span>
        <span class="k">return</span> <span class="n">rv</span></div>

<div class="viewcode-block" id="Underwriter.write_from_file"><a class="viewcode-back" href="../../underwriter.html#aggregate.underwriter.Underwriter.write_from_file">[docs]</a>    <span class="k">def</span> <span class="nf">write_from_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        read program from file. delegates to write</span>

<span class="sd">        :param file_name:</span>
<span class="sd">        :param update:</span>
<span class="sd">        :param verbose:</span>
<span class="sd">        :param log2:</span>
<span class="sd">        :param bs:</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">portfolio_program</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">portfolio_program</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Underwriter.write_test"><a class="viewcode-back" href="../../underwriter.html#aggregate.underwriter.Underwriter.write_test">[docs]</a>    <span class="k">def</span> <span class="nf">write_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">portfolio_program</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        write programs in testing mode</span>

<span class="sd">        dictionary definitions are added to uw but no objects are created</span>

<span class="sd">        returns data frame description of added severity/aggregate/portfolios</span>

<span class="sd">        the dataframe of aggregates can be used to create a portfolio (with all the aggregates) by calling</span>

<span class="sd">        ```Portfolio.from_DataFrame(name df)```</span>

<span class="sd">        TODO rationalize with parse_portfolio_program</span>

<span class="sd">        :param portfolio_program:</span>
<span class="sd">        :return: dictionary with keys sev agg port and assoicated dataframes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Runner.write_test | Executing program</span><span class="se">\n</span><span class="si">{portfolio_program[:500]}</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_runner</span><span class="p">(</span><span class="n">portfolio_program</span><span class="p">)</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">sev_out_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">sev_out_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">Underwriter</span><span class="o">.</span><span class="n">_add_defaults</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;sev&#39;</span><span class="p">)</span>
            <span class="n">ans</span><span class="p">[</span><span class="s1">&#39;sev&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">sev_out_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">sev_out_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">agg_out_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">agg_out_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">Underwriter</span><span class="o">.</span><span class="n">_add_defaults</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">ans</span><span class="p">[</span><span class="s1">&#39;agg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">agg_out_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">agg_out_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">port_out_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ans</span><span class="p">[</span><span class="s1">&#39;port&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">port_out_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">port_out_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">ans</span></div>

    <span class="k">def</span> <span class="nf">_runner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">portfolio_program</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        preprocessing:</span>
<span class="sd">            remove \n in [] (vectors) e.g. put by f{np.linspace} TODO only works for 1d vectors</span>
<span class="sd">            ; mapped to newline</span>
<span class="sd">            backslash (line continuation) mapped to space</span>
<span class="sd">            split on newlines</span>
<span class="sd">            parse one line at a time</span>
<span class="sd">            PIPE format no longer supported</span>

<span class="sd">        error handling and piping through parser</span>

<span class="sd">        :param portfolio_program:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Preprocess ---------------------------------------------------------------------</span>
        <span class="c1"># handle \n in vectors; first item is outside, then inside... (multidimensional??)</span>
        <span class="c1"># remove coments # xxx</span>
        <span class="n">portfolio_program</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s*#[^\n]*\n&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\n&#39;</span><span class="p">,</span> <span class="n">portfolio_program</span><span class="p">)</span>
        <span class="n">out_in</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\[|\]&#39;</span><span class="p">,</span> <span class="n">portfolio_program</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_in</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>  <span class="c1"># must be odd</span>
        <span class="n">odd</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">out_in</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]]</span>  <span class="c1"># replace inside []</span>
        <span class="n">even</span> <span class="o">=</span> <span class="n">out_in</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># otherwise pass through</span>
        <span class="c1"># reassemble</span>
        <span class="n">portfolio_program</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">even</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">f</span><span class="s1">&#39;[</span><span class="si">{o}</span><span class="s1">] </span><span class="si">{e}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">odd</span><span class="p">,</span> <span class="n">even</span><span class="p">[</span><span class="mi">1</span><span class="p">:])])</span>
        <span class="c1"># other preprocessing: line continuation; \n\t or \n____ to space (for port indents),</span>
        <span class="c1"># ; to new line, split on new line</span>
        <span class="n">portfolio_program</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">portfolio_program</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span>
                             <span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">    &#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span>
                             <span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Parse      ---------------------------------------------------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">program_line</span> <span class="ow">in</span> <span class="n">portfolio_program</span><span class="p">:</span>
            <span class="c1"># print(program_line)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">program_line</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">program_line</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
                    <span class="n">txt2</span> <span class="o">=</span> <span class="n">program_line</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="s1">&#39;&gt;&gt;&gt;&#39;</span> <span class="o">+</span> <span class="n">program_line</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Parse error in input &quot;</span><span class="si">{txt2}</span><span class="s1">&quot;</span><span class="se">\n</span><span class="s1">Value </span><span class="si">{v}</span><span class="s1"> of type </span><span class="si">{t}</span><span class="s1"> not expected&#39;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">e</span>

        <span class="c1"># Post process -------------------------------------------------------------------</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_mode</span><span class="p">:</span>
            <span class="c1"># could do this with a loop and getattr but it is too hard to read, so go easy route</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">sev_out_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># for k, v in self.parser.sev_out_dict.items():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">severity</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">sev_out_dict</span><span class="p">)</span>  <span class="c1"># [k] = v</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Underwriter._runner | saving {self.parser.sev_out_dict.keys()} severity/ies&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">agg_out_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># for k, v in self.parser.agg_out_dict.items():</span>
                <span class="c1">#     self.aggregate[k] = v</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">aggregate</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">agg_out_dict</span><span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Underwriter._runner | saving {self.parser.agg_out_dict.keys()} aggregate(s)&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">port_out_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">port_out_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># v is a list of aggregate names, these have all been added to the database...</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Underwriter._runner | saving </span><span class="si">{k}</span><span class="s1"> portfolio&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">portfolio</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;spec&#39;</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;spec&#39;</span><span class="p">],</span> <span class="s1">&#39;arg_dict&#39;</span><span class="p">:</span> <span class="p">{}}</span>
                    <span class="c1"># self.portfolio[k] = {&#39;spec&#39;: [self.aggregate[_a] for _a in v], &#39;arg_dict&#39;: {}}</span>
        <span class="c1"># can we still do something like this?</span>
        <span class="c1">#     self.parser.arg_dict[&#39;note&#39;] = txt</span>
        <span class="k">return</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_add_defaults</span><span class="p">(</span><span class="n">dict_</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;agg&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        add default values to dict_ Leave existing values unchanged</span>

<span class="sd">        :param dict_:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">exp_el</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">exp_premium</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">exp_lr</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">exp_en</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">exp_attachment</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">exp_limit</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                        <span class="n">sev_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">sev_a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sev_b</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sev_mean</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sev_cv</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sev_scale</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sev_loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sev_wt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">freq_name</span><span class="o">=</span><span class="s1">&#39;poisson&#39;</span><span class="p">,</span> <span class="n">freq_a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">freq_b</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;agg&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dict_</span><span class="p">:</span>
                    <span class="n">dict_</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;sev&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;sev&#39;</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dict_</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;sev_wt&#39;</span><span class="p">:</span>
                    <span class="n">dict_</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">_safe_lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_uw_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        lookup uw_id in uw of expected type and merge safely into self.arg_dict</span>
<span class="sd">        delete name and note if appropriate</span>

<span class="sd">        :param full_uw_id:  type.name format</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">expected_type</span><span class="p">,</span> <span class="n">uw_id</span> <span class="o">=</span> <span class="n">full_uw_id</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># lookup in Underwriter</span>
            <span class="n">found_type</span><span class="p">,</span> <span class="n">found_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">uw_id</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">LookupError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;ERROR id </span><span class="si">{expected_type}</span><span class="s1">.</span><span class="si">{uw_id}</span><span class="s1"> not found&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">e</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;UnderwritingParser._safe_lookup | retrieved </span><span class="si">{uw_id}</span><span class="s1"> as type </span><span class="si">{found_type}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">found_type</span> <span class="o">!=</span> <span class="n">expected_type</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Error: type of </span><span class="si">{uw_id}</span><span class="s1"> is  </span><span class="si">{found_type}</span><span class="s1">, not expected </span><span class="si">{expected_type}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">found_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<div class="viewcode-block" id="Underwriter.obj_to_agg"><a class="viewcode-back" href="../../underwriter.html#aggregate.underwriter.Underwriter.obj_to_agg">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">obj_to_agg</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        convert an object into an agg language specification, used for saving</span>
<span class="sd">        :param obj: a dictionary, Aggregate, Severity or Portfolio object</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>

<span class="c1"># def dict_2_string(type_name, dict_in, tab_level=0, sio=None):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     nice formating for str function</span>
<span class="c1">#</span>
<span class="c1">#     :param type_name:</span>
<span class="c1">#     :param dict_in:</span>
<span class="c1">#     :param tab_level:</span>
<span class="c1">#     :param sio:</span>
<span class="c1">#     :return:</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#     if sio is None:</span>
<span class="c1">#         sio = StringIO()</span>
<span class="c1">#</span>
<span class="c1">#     keys = sorted(dict_in.keys())</span>
<span class="c1">#     if &#39;name&#39; in keys:</span>
<span class="c1">#         # which it should always be</span>
<span class="c1">#         nm = dict_in[&#39;name&#39;]</span>
<span class="c1">#         sio.write(nm + &#39;\n&#39; + &#39;=&#39; * len(nm) + &#39;\n&#39;)</span>
<span class="c1">#         keys.pop(keys.index(&#39;name&#39;))</span>
<span class="c1">#</span>
<span class="c1">#     sio.write(f&#39;{&quot;type&quot;:&lt;20s}{type_name}\n&#39;)</span>
<span class="c1">#</span>
<span class="c1">#     for k in keys:</span>
<span class="c1">#         v = dict_in[k]</span>
<span class="c1">#         ks = &#39;\t&#39; * max(0, tab_level - 1) + f&#39;{str(k):&lt;20s}&#39;</span>
<span class="c1">#         if type(v) == dict:</span>
<span class="c1">#             # sio.write(&#39;\t&#39; * tab_level + ks + &#39;\n&#39;)</span>
<span class="c1">#             dict_2_string(type(v), v, tab_level + 1, sio)</span>
<span class="c1">#         elif isinstance(v, str):</span>
<span class="c1">#             if len(v) &gt; 30:</span>
<span class="c1">#                 sio.write(&#39;\t&#39; * tab_level + ks + &#39;\n&#39; + indent(fill(v, 30), &#39; &#39; * (4 * tab_level + 20)))</span>
<span class="c1">#             elif len(v) &gt; 0:</span>
<span class="c1">#                 sio.write(&#39;\t&#39; * tab_level + ks + v)</span>
<span class="c1">#             sio.write(&#39;\n&#39;)</span>
<span class="c1">#         elif isinstance(v, collections.Iterable):</span>
<span class="c1">#             sio.write(&#39;\t&#39; * tab_level + ks + &#39;\n&#39;)</span>
<span class="c1">#             for vv in v:</span>
<span class="c1">#                 sio.write(&#39;\t&#39; * (tab_level + 1) + str(vv) + &#39;\n&#39;)</span>
<span class="c1">#         elif type(v) == int:</span>
<span class="c1">#             sio.write(&#39;\t&#39; * tab_level + f&#39;{ks}\t{v:20d}\n&#39;)</span>
<span class="c1">#         elif type(v) == float:</span>
<span class="c1">#             if abs(v) &lt; 100:</span>
<span class="c1">#                 sio.write(&#39;\t&#39; * tab_level + f&#39;{ks}\t{v:20.5f}\n&#39;)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 sio.write(&#39;\t&#39; * tab_level + f&#39;{ks}\t{v:20,.1f}\n&#39;)</span>
<span class="c1">#         else:</span>
<span class="c1">#             # logging.info(f&#39;Uknown type {type(v)} to dict_2_string&#39;)</span>
<span class="c1">#             sio.write(&#39;\t&#39; * tab_level + ks + &#39;\t&#39; + str(v) + &#39;\n&#39;)</span>
<span class="c1">#     return sio.getvalue()</span>
</pre></div>

          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">

        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2018-19 Convex Risk LLC.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 2.2.1.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>