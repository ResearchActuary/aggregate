<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>Distribution Classes &mdash; aggregate 0.7.1 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="_static/css/spc-extend.css">
    <link rel="stylesheet" href="_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="None"></script>
    <script type="text/javascript" src="_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="genindex.html" >
    <link rel="search" title="Search" href="search.html" >
    <link rel="top" title="aggregate 0.7.1 documentation" href="index.html" >
    <link rel="next" title="Portfolio Class" href="portfolio.html" >
    <link rel="prev" title="Development Outline" href="devel.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="index.html">
      <img style="border: 0;" alt="SciPy" src="_static/img/scipy_org_logo.gif"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="https://github.com/mynl/aggregate">aggregate Code</a></li>
	
        <li class="active"><a href="index.html">aggregate 0.7.1 documentation</a></li>
	 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="portfolio.html" title="Portfolio Class"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="devel.html" title="Development Outline"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="module-aggregate.distr">
<span id="distribution-classes"></span><h1>Distribution Classes<a class="headerlink" href="#module-aggregate.distr" title="Permalink to this headline">¶</a></h1>
<div class="section" id="frequency-class">
<h2>Frequency Class<a class="headerlink" href="#frequency-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="aggregate.distr.Frequency">
<em class="property">class </em><code class="sig-prename descclassname">aggregate.distr.</code><code class="sig-name descname">Frequency</code><span class="sig-paren">(</span><em class="sig-param">freq_name</em>, <em class="sig-param">freq_a</em>, <em class="sig-param">freq_b</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Frequency"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Manages Frequency distributions: creates moment function and MGF.</p>
<p>freq_moms(n): returns EN, EN^2 and EN^3 when EN=n</p>
<p>mgf(n, z): returns the moment generating function applied to z when EN=n</p>
<p><strong>Available Frequency Distributions</strong></p>
<p><strong>Non-Mixture</strong> Types</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fixed</span></code>: no parameters</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bernoulli</span></code>: exp_en interpreted as a probability, must be &lt; 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">binomial</span></code>: Binomial(n, p) where p = freq_a, and n = exp_en</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">poisson</span></code>: Poisson(freq_a)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pascal</span></code>: pascal-poisson distribution, a poisson stopped sum of negative binomial; exp_en gives the overall
claim count. freq_a is the CV of the negative binomial distribution and freq_b is the
number of claimants per claim (or claims per occurrence). Hence the Poisson component
has mean exp_en / freq_b and the number of claims per occurrence has mean freq_b and
cv freq_a</p></li>
</ul>
<p><strong>Mixture</strong> Types</p>
<p>These distributions are G-mixed Poisson, so N | G ~ Poisson(n G). They are labelled by
the name of the mixing distribution or the common name for the resulting frequency
distribution. See Panjer and Willmot or JKK.</p>
<p>In all cases freq_a is the CV of the mixing distribution which corresponds to the
asympototic CV of the frequency distribution and of any aggregate when the severity has a variance.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">gamma</span></code>: negative binomial, freq_a = cv of gamma distribution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">delaporte</span></code>: shifted gamma, freq_a = cv of mixing disitribution, freq_b = proportion of
certain claims = shift. freq_b must be between 0 and 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ig</span></code>: inverse gaussian, freq_a = cv of mixing distribution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sig</span></code>: shifted inverse gaussian, freq_a = cv of mixing disitribution, freq_b = proportion of
certain claims = shift. freq_b must be between 0 and 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sichel</span></code>: generalized inverse gaussian mixing distribution, freq_a = cv of mixing distribution and
freq_b = lambda value. The beta and mu parameters solved to match moments. Note lambda =
-0.5 corresponds to inverse gaussian and 0.5 to reciprocal inverse gauusian. Other special
cases are available.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sichel.nb</span></code>: generalized inverse gaussian mixture where the parameters match the moments of a
delaporte distribution with given freq_a and freq_b</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sichel.ig</span></code>: generalized inverse gaussian mixture where the parameters match the moments of a
shifted inverse gaussian distribution with given freq_a and freq_b. This parameterization
has poor numerical stability and may fail.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">beta</span></code>: beta mixing with freq_a = Cv where beta is supported on the interval [0, freq_b]. This
method should be used carefully. It has poor numerical stability and can produce bizzare
aggregates when the alpha or beta parameters are &lt; 1 (so there is a mode at 0 or freq_b).</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>freq_name</strong> – </p></li>
<li><p><strong>freq_a</strong> – </p></li>
<li><p><strong>freq_b</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="severity-class">
<h2>Severity Class<a class="headerlink" href="#severity-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="aggregate.distr.Severity">
<em class="property">class </em><code class="sig-prename descclassname">aggregate.distr.</code><code class="sig-name descname">Severity</code><span class="sig-paren">(</span><em class="sig-param">sev_name</em>, <em class="sig-param">exp_attachment=0</em>, <em class="sig-param">exp_limit=inf</em>, <em class="sig-param">sev_mean=0</em>, <em class="sig-param">sev_cv=0</em>, <em class="sig-param">sev_a=0</em>, <em class="sig-param">sev_b=0</em>, <em class="sig-param">sev_loc=0</em>, <em class="sig-param">sev_scale=0</em>, <em class="sig-param">sev_xs=None</em>, <em class="sig-param">sev_ps=None</em>, <em class="sig-param">conditional=True</em>, <em class="sig-param">name=''</em>, <em class="sig-param">note=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Severity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Severity" title="Permalink to this definition">¶</a></dt>
<dd><p>A continuous random variable, subclasses <code class="docutils literal notranslate"><span class="pre">scipy.statistics_df.rv_continuous</span></code>.</p>
<p>adds layer and attachment to scipy statistics_df continuous random variable class
overrides</p>
<ul class="simple">
<li><p>cdf</p></li>
<li><p>pdf</p></li>
<li><p>isf</p></li>
<li><p>ppf</p></li>
<li><p>moments</p></li>
</ul>
<p>Should consider over-riding: sf, <strong>statistics_df</strong> ?munp</p>
<p>TODO issues remain using numerical integration to compute moments for distributions having
infinite support and a low standard deviation. See logging for more information in particular
cases.</p>
<dl class="method">
<dt id="aggregate.distr.Severity.cv_to_shape">
<code class="sig-name descname">cv_to_shape</code><span class="sig-paren">(</span><em class="sig-param">cv</em>, <em class="sig-param">hint=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Severity.cv_to_shape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Severity.cv_to_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>create a frozen object of type dist_name with given cv</p>
<p>lognormal, gamma, inverse gamma and inverse gaussian solved analytically.</p>
<p>Other distributions solved numerically and may be unstable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cv</strong> – </p></li>
<li><p><strong>hint</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aggregate.distr.Severity.mean_to_scale">
<code class="sig-name descname">mean_to_scale</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">mean</em>, <em class="sig-param">loc=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Severity.mean_to_scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Severity.mean_to_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust scale of fz to have desired mean
return frozen instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shape</strong> – </p></li>
<li><p><strong>mean</strong> – </p></li>
<li><p><strong>loc</strong> – location parameter (note: location is added to the mean…)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aggregate.distr.Severity.moms">
<code class="sig-name descname">moms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Severity.moms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Severity.moms" title="Permalink to this definition">¶</a></dt>
<dd><p>moms method
remember have to use integral of survival function otherwise quad can fail to “see” the distribution
for unlimited integral of a low sd variable</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aggregate.distr.Severity.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param">N=100</em>, <em class="sig-param">axiter=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Severity.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Severity.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>quick plot</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axiter</strong> – </p></li>
<li><p><strong>N</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="aggregate-class">
<h2>Aggregate Class<a class="headerlink" href="#aggregate-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="aggregate.distr.Aggregate">
<em class="property">class </em><code class="sig-prename descclassname">aggregate.distr.</code><code class="sig-name descname">Aggregate</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">exp_el=0</em>, <em class="sig-param">exp_premium=0</em>, <em class="sig-param">exp_lr=0</em>, <em class="sig-param">exp_en=0</em>, <em class="sig-param">exp_attachment=0</em>, <em class="sig-param">exp_limit=inf</em>, <em class="sig-param">sev_name=''</em>, <em class="sig-param">sev_a=0</em>, <em class="sig-param">sev_b=0</em>, <em class="sig-param">sev_mean=0</em>, <em class="sig-param">sev_cv=0</em>, <em class="sig-param">sev_loc=0</em>, <em class="sig-param">sev_scale=0</em>, <em class="sig-param">sev_xs=None</em>, <em class="sig-param">sev_ps=None</em>, <em class="sig-param">sev_wt=1</em>, <em class="sig-param">freq_name=''</em>, <em class="sig-param">freq_a=0</em>, <em class="sig-param">freq_b=0</em>, <em class="sig-param">note=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Aggregate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Aggregate" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>Aggregate distribution class manages creation and calculation of aggregate distributions.</dt><dd><p>Aggregate allows for very flexible creation of Aggregate distributions. Severity
can express a limit profile, a mixed severity or both. Mixed frequency types share
a mixing distribution across all broadcast terms to ensure an appropriate inter-
class correlation.</p>
</dd>
<dt>Limit Profiles</dt><dd><p>The exposure variables can be vectors to express a <em>limit profile</em>.
All <code class="docutils literal notranslate"><span class="pre">`exp_[en|prem|loss|count]`</span></code> related elements are broadcast against one-another.
For example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">100</span> <span class="mi">200</span> <span class="mi">400</span> <span class="mi">100</span><span class="p">]</span> <span class="n">premium</span> <span class="n">at</span> <span class="mf">0.65</span> <span class="n">lr</span> <span class="p">[</span><span class="mi">1000</span> <span class="mi">2000</span> <span class="mi">5000</span> <span class="mi">10000</span><span class="p">]</span> <span class="n">xs</span> <span class="mi">1000</span>
</pre></div>
</div>
<p>expresses a limit profile with 100 of premium at 1000 x 1000; 200 at 2000 x 1000
400 at 5000 x 1000 and 100 at 10000 x 1000. In this case all the loss ratios are
the same, but they could vary too, as could the attachments.</p>
</dd>
<dt>Mixtures</dt><dd><p>The severity variables can be vectors to express a <em>mixed severity</em>. All <code class="docutils literal notranslate"><span class="pre">sev_</span></code>
elements are broadcast against one-another. For example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sev</span> <span class="n">lognorm</span> <span class="mi">1000</span> <span class="n">cv</span> <span class="p">[</span><span class="mf">0.75</span> <span class="mf">1.0</span> <span class="mf">1.25</span> <span class="mf">1.5</span> <span class="mi">2</span><span class="p">]</span> <span class="n">wts</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
</pre></div>
</div>
<p>expresses a mixture of five lognormals with a mean of 1000 and CVs as indicated with
weights 0.4, 0.2, 0.1, 0.1, 0.1. Equal weights can be express as wts=[5], or the
relevant number of components.</p>
</dd>
<dt>Limit Profiles and Mixtures</dt><dd><p>Limit profiles and mixtures can be combined. Each mixed severity is applied to each
limit profile component. For example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ag</span> <span class="o">=</span> <span class="n">uw</span><span class="p">(</span><span class="s1">&#39;agg multiExp [10 20 30] claims [100 200 75] xs [0 50 75]</span>
    <span class="n">sev</span> <span class="n">lognorm</span> <span class="mi">100</span> <span class="n">cv</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span> <span class="n">wts</span> <span class="p">[</span><span class="o">.</span><span class="mi">6</span> <span class="o">.</span><span class="mi">4</span><span class="p">]</span> <span class="n">mixed</span> <span class="n">gamma</span> <span class="mf">0.4</span><span class="s1">&#39;)```</span>
</pre></div>
</div>
<p>creates an aggregate with six severity subcomponents</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 23%" />
<col style="width: 40%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>#</p></th>
<th class="head"><p>limit</p></th>
<th class="head"><p>attachment</p></th>
<th class="head"><p>claims</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>100</p></td>
<td><p>0</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>100</p></td>
<td><p>0</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>200</p></td>
<td><p>50</p></td>
<td><p>12</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>200</p></td>
<td><p>50</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>75</p></td>
<td><p>75</p></td>
<td><p>18</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>75</p></td>
<td><p>75</p></td>
<td><p>12</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Circumventing Products</dt><dd><p>It is sometimes desirable to enter two or more lines each with a different severity but
with a shared mixing variable. For example to model the current accident year and a run-
off reserve, where the current year is gamma mean 100 cv 1 and the reserves are
larger lognormal mean 150 cv 0.5 claims requires</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">agg</span> <span class="n">MixedPremReserve</span> <span class="p">[</span><span class="mi">100</span> <span class="mi">200</span><span class="p">]</span> <span class="n">claims</span> <span class="n">sev</span> <span class="p">[</span><span class="n">gamma</span> <span class="n">lognorm</span><span class="p">]</span> <span class="p">[</span><span class="mi">100</span> <span class="mi">150</span><span class="p">]</span> <span class="n">cv</span> <span class="p">[</span><span class="mi">1</span> <span class="mf">0.5</span><span class="p">]</span> <span class="n">mixed</span> <span class="n">gamma</span> <span class="mf">0.4</span>
</pre></div>
</div>
<p>so that the result is not the four-way exposure / severity product but just a two-way
combination. These two cases are distinguished looking at the total weights. If the weights sum to
one then the result is an exposure / severity product. If the weights are missing or sum to the number
of severity components (i.e. are all equal to 1) then the result is a row by row combination.</p>
</dd>
<dt>Other Programs</dt><dd><p>Below are a series of programs illustrating the different ways exposure, frequency and severity can be
broadcast together, several different types of severity and all the different types of severity.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test_string_0</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1"># use to create sev and aggs so can illustrate use of sev. and agg. below</span>

<span class="s1">sev sev1 lognorm 10 cv .3</span>

<span class="s1">agg Agg0 1 claim sev lognorm 10 cv .09 fixed</span>

<span class="s1">&#39;&#39;&#39;</span>

<span class="n">test_string_1</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">agg Agg1  1 claim sev {10*np.exp(-.3**2/2)} * lognorm .3      fixed note{{sigma=.3 mean=10}}</span>
<span class="s1">agg Agg2  1 claim sev {10*np.exp(-.3**2/2)} * lognorm .3 + 5  fixed note{{shifted right by 5}}&#39;&#39;&#39;</span>             <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">agg Agg3  1 claim sev 10 * lognorm 0.5 cv .3                  fixed note{mean 0.5 scaled by 10 and cv 0.3}</span>
<span class="s1">agg Agg4  1 claim sev 10 * lognorm 1 cv .5 + 5                fixed note{shifted right by 5}</span>

<span class="s1">agg Agg5  1 claim sev 10 * gamma .3                           fixed note{gamma distribution....can use any two parameter scipy.stats distribution plus expon, uniform and normal}</span>
<span class="s1">agg Agg6  1 claim sev 10 * gamma 1 cv .3 + 5                  fixed note{mean 10 x 1, cv 0.3 shifted right by 5}</span>

<span class="s1">agg Agg7  1 claim sev 2 * pareto 1.6 - 2                      fixed note{pareto alpha=1.6 lambda=2}</span>
<span class="s1">agg Agg8  1 claim sev 2 * uniform 5 + 2.5                     fixed note{uniform 2.5 to 12.5}</span>

<span class="s1">agg Agg9  1 claim 10 x  2 sev lognorm 20 cv 1.5               fixed note{10 x 2 layer, 1 claim}</span>
<span class="s1">agg Agg10 10 loss 10 xs 2 sev lognorm 20 cv 1.5               fixed note{10 x 2 layer, total loss 10, derives requency}</span>
<span class="s1">agg Agg11 14 prem at .7    10 x 1 sev lognorm 20 cv 1.5       fixed note{14 prem at .7 lr derive frequency}</span>
<span class="s1">agg Agg11 14 prem at .7 lr 10 x 1 sev lognorm 20 cv 1.5       fixed note{14 prem at .7 lr derive frequency, lr is optional}</span>

<span class="s1">agg Agg12: 14 prem at .7 lr (10 x 1) sev (lognorm 20 cv 1.5)  fixed note{trailing semi and other punct ignored};</span>

<span class="s1">agg Agg13: 1 claim sev 50 * beta 3 2 + 10 fixed note{scaled and shifted beta, two parameter distribution}</span>
<span class="s1">agg Agg14: 1 claim sev 100 * expon + 10   fixed note{exponential single parameter, needs scale, optional shift}</span>
<span class="s1">agg Agg15: 1 claim sev 10 * norm + 50     fixed note{normal is single parameter too, needs scale, optional shift}</span>

<span class="s1"># any scipy.stat distribution taking one parameter can be used; only cts vars supported on R+ make sense</span>
<span class="s1">agg Agg16: 1 claim sev 1 * invgamma 4.07 fixed  note{inverse gamma distribution}</span>

<span class="s1"># mixtures</span>
<span class="s1">agg MixedLine1: 1 claim 25 xs 0 sev lognorm 10                   cv [0.2, 0.4, 0.6, 0.8, 1.0] wts=5             fixed note{equally weighted mixture of 5 lognormals different cvs}</span>
<span class="s1">agg MixedLine2: 1 claim 25 xs 0 sev lognorm [10, 15, 20, 25, 50] cv [0.2, 0.4, 0.6, 0.8, 1.0] wts=5             fixed note{equal weighted mixture of 5 lognormals different cvs and means}</span>
<span class="s1">agg MixedLine3: 1 claim 25 xs 0 sev lognorm 10                   cv [0.2, 0.4, 0.6, 0.8, 1.0] wt [.2, .3, .3, .15, .05]   fixed note{weights scaled to equal 1 if input}</span>

<span class="s1"># limit profile</span>
<span class="s1">agg LimitProfile1: 1 claim [1, 5, 10, 20] xs 0 sev lognorm 10 cv 1.2 wt [.50, .20, .20, .1]   fixed note{maybe input EL by band for wt}</span>
<span class="s1">agg LimitProfile2: 5 claim            20  xs 0 sev lognorm 10 cv 1.2 wt [.50, .20, .20, .1]   fixed note{input EL by band for wt}</span>
<span class="s1">agg LimitProfile3: [10 10 10 10] claims [inf 10 inf 10] xs [0 0 5 5] sev lognorm 10 cv 1.25   fixed note{input counts directly}</span>

<span class="s1"># limits and distribution blend</span>
<span class="s1">agg Blend1 50  claims [5 10 15] x 0         sev lognorm 12 cv [1, 1.5, 3]          fixed note{options all broadcast against one another, 50 claims of each}</span>
<span class="s1">agg Blend2 50  claims [5 10 15] x 0         sev lognorm 12 cv [1, 1.5, 3] wt=3     fixed note{options all broadcast against one another, 50 claims of each}</span>

<span class="s1">agg Blend5cv1  50 claims  5 x 0 sev lognorm 12 cv 1 fixed</span>
<span class="s1">agg Blend10cv1 50 claims 10 x 0 sev lognorm 12 cv 1 fixed</span>
<span class="s1">agg Blend15cv1 50 claims 15 x 0 sev lognorm 12 cv 1 fixed</span>

<span class="s1">agg Blend5cv15  50 claims  5 x 0 sev lognorm 12 cv 1.5 fixed</span>
<span class="s1">agg Blend10cv15 50 claims 10 x 0 sev lognorm 12 cv 1.5 fixed</span>
<span class="s1">agg Blend15cv15 50 claims 15 x 0 sev lognorm 12 cv 1.5 fixed</span>

<span class="s1"># semi colon can be used for newline and backslash works</span>
<span class="s1">agg Blend5cv3  50 claims  5 x 0 sev lognorm 12 cv 3 fixed; agg Blend10cv3 50 claims 10 x 0 sev lognorm 12 cv 3 fixed</span>
<span class="s1">agg Blend15cv3 50 claims 15 x 0 sev             lognorm 12 cv 3 fixed</span>

<span class="s1"># not sure if it will broadcast limit profile against severity mixture...</span>
<span class="s1">agg LimitProfile4: [10 30 15 5] claims [inf 10 inf 10] xs [0 0 5 5] sev lognorm 10 cv [1.0, 1.25, 1.5] wts=3  fixed note{input counts directly}</span>
<span class="s1">&#39;&#39;&#39;</span>             <span class="n">f</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1"># the logo</span>
<span class="s1">agg logo 1 claim {np.linspace(10, 250, 20)} xs 0 sev lognorm 100 cv 1 fixed&#39;&#39;&#39;</span>

<span class="n">test_string_2</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1"># empirical distributions</span>
<span class="s1">agg dHist1 1 claim sev dhistogram xps [1, 10, 40] [.5, .3, .2] fixed     note{discrete histogram}</span>
<span class="s1">agg cHist1 1 claim sev chistogram xps [1, 10, 40] [.5, .3, .2] fixed     note{continuous histogram, guessed right hand endpiont}</span>
<span class="s1">agg cHist2 1 claim sev chistogram xps [1 10 40 45] [.5 .3 .2]  fixed     note{continuous histogram, explicit right hand endpoint, don&#39;t need commas}</span>
<span class="s1">agg BodoffWind  1 claim sev dhistogram xps [0,  99] [0.80, 0.20] fixed   note{examples from Bodoffs paper}</span>
<span class="s1">agg BodoffQuake 1 claim sev dhistogram xps [0, 100] [0.95, 0.05] fixed</span>

<span class="s1"># set up fixed sev for future use</span>
<span class="s1">sev One dhistogram xps [1] [1]   note{a certain loss of 1}</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="n">test_string_3</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1"># sev, agg and port: using built in objects [have to exist prior to running program]</span>
<span class="s1">agg ppa:       0.01 * agg.PPAL       note{this is using lmult on aggs, needs a dictionary specification to adjust means}</span>
<span class="s1">agg cautoQS:   1e-5 * agg.CAL        note{lmult is quota share or scale for rmul see below }</span>
<span class="s1">agg cautoClms: agg.CAL * 1e-5        note{rmult adjusts the claim count}</span>

<span class="s1"># scaling works with distributions already made by uw</span>
<span class="s1">agg mdist: 5000 * agg.dHist1</span>

<span class="s1">&#39;&#39;&#39;</span>

<span class="n">test_string_4</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1"># frequency options</span>
<span class="s1">agg FreqFixed      10 claims sev sev.One fixed</span>
<span class="s1">agg FreqPoisson    10 claims sev sev.One poisson                   note{Poisson frequency}</span>
<span class="s1">agg FreqBernoulli  .8 claims sev sev.One bernoulli               note{Bernoulli en is frequency }</span>
<span class="s1">agg FreqBinomial   10 claims sev sev.One binomial 0.5</span>
<span class="s1">agg FreqPascal     10 claims sev sev.One pascal .8 3</span>

<span class="s1"># mixed freqs</span>
<span class="s1">agg FreqNegBin     10 claims sev sev.One (mixed gamma 0.65)     note{gamma mixed Poisson = negative binomial}</span>
<span class="s1">agg FreqDelaporte  10 claims sev sev.One mixed delaporte .65 .25</span>
<span class="s1">agg FreqIG         10 claims sev sev.One mixed ig  .65</span>
<span class="s1">agg FreqSichel     10 claims sev sev.One mixed delaporte .65 -0.25</span>
<span class="s1">agg FreqSichel.nb  10 claims sev sev.One mixed delaporte .65 .25</span>
<span class="s1">agg FreqSichel.ig  10 claims sev sev.One mixed delaporte .65 .25</span>
<span class="s1">agg FreqBeta       10 claims sev sev.One mixed beta .5  4  note{second param is max mix}</span>
<span class="s1">&#39;&#39;&#39;</span>
<span class="n">test_strings</span> <span class="o">=</span> <span class="p">[</span><span class="n">test_string_0</span><span class="p">,</span> <span class="n">test_string_1</span><span class="p">,</span> <span class="n">test_string_2</span><span class="p">,</span> <span class="n">test_string_3</span><span class="p">,</span> <span class="n">test_string_4</span><span class="p">]</span>

<span class="c1"># run the various tests</span>
<span class="n">uw</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">Underwriter</span><span class="p">()</span>
<span class="n">uw</span><span class="o">.</span><span class="n">glob</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()</span>
<span class="n">uw</span><span class="o">.</span><span class="n">create_all</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">uw</span><span class="o">.</span><span class="n">update</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">uw</span><span class="o">.</span><span class="n">log2</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">ans</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c1"># make sure we have this base first:</span>
<span class="n">uw</span><span class="p">(</span><span class="s1">&#39;sev One dhistogram xps [1] [1]   note{a certain loss of 1}&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">test_strings</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;line </span><span class="si">{i}</span><span class="s1"> of {len(test_strings)}&#39;</span><span class="p">)</span>
    <span class="n">ans</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">uw</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
</dd>
<dt>Other Notes</dt><dd><p>How Expected Claim Count is determined etc.
* en determines en
* prem x loss ratio -&gt; el
* severity x en -&gt; el</p>
<ul class="simple">
<li><p>always have en and el; may have prem and exp_lr</p></li>
<li><p>if prem then exp_lr computed</p></li>
<li><p>if exp_lr then premium computed</p></li>
<li><p>el is determined using np.where(el==0, prem*exp_lr, el)</p></li>
<li><p>if el==0 then el = freq * sev</p></li>
<li><p>assert np.all( el&gt;0 or en&gt;0 )</p></li>
<li><p>call with el (or prem x exp_lr) (or n) expressing a mixture, with the same severity</p></li>
<li><p>call with el expressing lines of business with an array of severities</p></li>
<li><p>call with single el and array of sevs expressing a mixture; [] broken down by weights</p></li>
<li><p>n is the CONDITIONAL claim count</p></li>
<li><p>X is the GROUND UP severity, so X | X &gt; attachment is used and generates n claims</p></li>
<li><p>For fixed or histogram have to separate the parameter so they are not broad cast; otherwise
you end up with multiple lines when you intend only one</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">param name</dt>
<dd class="field-odd"><p>name of the aggregate</p>
</dd>
<dt class="field-even">param exp_el</dt>
<dd class="field-even"><p>expected loss or vector</p>
</dd>
<dt class="field-odd">param exp_premium</dt>
<dd class="field-odd"><p>premium volume or vector  (requires loss ratio)</p>
</dd>
<dt class="field-even">param exp_lr</dt>
<dd class="field-even"><p>loss ratio or vector  (requires premium)</p>
</dd>
<dt class="field-odd">param exp_en</dt>
<dd class="field-odd"><p>expected claim count per segment (self.n = total claim count)</p>
</dd>
<dt class="field-even">param exp_attachment</dt>
<dd class="field-even"><p>occurrence attachment</p>
</dd>
<dt class="field-odd">param exp_limit</dt>
<dd class="field-odd"><p>occurrence limit</p>
</dd>
<dt class="field-even">param sev_name</dt>
<dd class="field-even"><p>severity name or sev.BUILTIN_SEV or meta.var agg or port or similar or vector or matrix</p>
</dd>
<dt class="field-odd">param sev_a</dt>
<dd class="field-odd"><p>scipy stats shape parameter</p>
</dd>
<dt class="field-even">param sev_b</dt>
<dd class="field-even"><p>scipy stats shape parameter</p>
</dd>
<dt class="field-odd">param sev_mean</dt>
<dd class="field-odd"><p>average (unlimited) severity</p>
</dd>
<dt class="field-even">param sev_cv</dt>
<dd class="field-even"><p>unlimited severity coefficient of variation</p>
</dd>
<dt class="field-odd">param sev_loc</dt>
<dd class="field-odd"><p>scipy stats location parameter</p>
</dd>
<dt class="field-even">param sev_scale</dt>
<dd class="field-even"><p>scipy stats scale parameter</p>
</dd>
<dt class="field-odd">param sev_xs</dt>
<dd class="field-odd"><p>xs and ps must be provided if sev_name is (c|d)histogram, xs are the bucket break points</p>
</dd>
<dt class="field-even">param sev_ps</dt>
<dd class="field-even"><p>ps are the probability densities within each bucket; if buckets equal size no adjustments needed</p>
</dd>
<dt class="field-odd">param sev_wt</dt>
<dd class="field-odd"><p>weight for mixed distribution</p>
</dd>
<dt class="field-even">param freq_name</dt>
<dd class="field-even"><p>name of frequency distribution</p>
</dd>
<dt class="field-odd">param freq_a</dt>
<dd class="field-odd"><p>cv of freq dist mixing distribution</p>
</dd>
<dt class="field-even">param freq_b</dt>
<dd class="field-even"><p>claims per occurrence (delaporte or sig), scale of beta or lambda (Sichel)</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="aggregate.distr.Aggregate.agg_lang">
<code class="sig-name descname">agg_lang</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Aggregate.agg_lang"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Aggregate.agg_lang" title="Permalink to this definition">¶</a></dt>
<dd><p>write in aggregate language…
:return:</p>
</dd></dl>

<dl class="method">
<dt id="aggregate.distr.Aggregate.cdf">
<code class="sig-name descname">cdf</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Aggregate.cdf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Aggregate.cdf" title="Permalink to this definition">¶</a></dt>
<dd><p>return cumulative probability distribution using linear interpolation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – loss size</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aggregate.distr.Aggregate.delbaen_haezendonck_density">
<code class="sig-name descname">delbaen_haezendonck_density</code><span class="sig-paren">(</span><em class="sig-param">xs</em>, <em class="sig-param">padding</em>, <em class="sig-param">tilt_vector</em>, <em class="sig-param">beta</em>, <em class="sig-param">beta_name=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Aggregate.delbaen_haezendonck_density"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Aggregate.delbaen_haezendonck_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare the base and Delbaen Haezendonck transformed aggregates</p>
<ul class="simple">
<li><p>beta(x) = alpha + gamma(x)</p></li>
<li><p>alpha = log(freq’ / freq): log of the increase in claim count</p></li>
<li><p>gamma = log(Radon Nikodym derv of adjusted severity) = log(tilde f / f)</p></li>
</ul>
<p>Adjustment guarantees a positive loading iff beta is an increasing function
iff gamma is increasing iff tilde f / f is increasing.
cf. eqn 3.7 and 3.8</p>
<p>Note conditions that E(exp(beta(X)) and E(X exp(beta(X)) must both be finite (3.4, 3.5)
form of beta function described in 2.23 via, 2.16-17 and 2.18</p>
<p>From examples on last page of paper:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">beta</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span> <span class="o">==&gt;</span> <span class="n">adjust</span> <span class="n">frequency</span> <span class="n">by</span> <span class="n">factor</span> <span class="n">of</span> <span class="n">e</span><span class="o">^</span><span class="n">a</span>
<span class="n">beta</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">b</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">E</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span>  <span class="o">==&gt;</span> <span class="n">variance</span> <span class="n">principle</span> <span class="n">EN</span><span class="p">(</span><span class="n">EX</span> <span class="o">+</span> <span class="n">bVar</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="n">beta</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">ax</span><span class="o">-</span> <span class="n">logE_P</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">a</span> <span class="n">x</span><span class="p">))</span>  <span class="o">==&gt;</span> <span class="n">Esscher</span> <span class="n">principle</span>
</pre></div>
</div>
<p>To make a ‘multiple’ of an existing distortion you can use a simple wrapper class like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">dist_wrap</span><span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">Distortion</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    wrap a distortion to include higher or lower freq</span>
<span class="sd">    in DH α is actually exp(α)</span>
<span class="sd">    this will pass isinstance(g2, agg.Distortion)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">α</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">loc_g</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">α</span> <span class="o">*</span> <span class="n">dist</span><span class="o">.</span><span class="n">g</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">loc_g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> – is part of agg so can use that</p></li>
<li><p><strong>padding</strong> – = 1 (default)</p></li>
<li><p><strong>tilt_vector</strong> – None (default)</p></li>
<li><p><strong>beta</strong> – function R+ to R with appropriate properties or name of prob distortion function</p></li>
<li><p><strong>beta_name</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aggregate.distr.Aggregate.discretize">
<code class="sig-name descname">discretize</code><span class="sig-paren">(</span><em class="sig-param">sev_calc</em>, <em class="sig-param">discretization_calc='survival'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Aggregate.discretize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Aggregate.discretize" title="Permalink to this definition">¶</a></dt>
<dd><p>Continuous is used when you think of the resulting distribution as continuous across the buckets
(which we generally don’t). We use the discretized distribution as though it is fully discrete
and only takes values at the bucket points. Hence we should use sev_calc=’discrete’. The buckets are
shifted left by half a bucket, so <span class="math notranslate nohighlight">\(Pr(X=b_i) = Pr( b_i - b/2 &lt; X &lt;= b_i + b/2)\)</span>.</p>
<p>The other wrinkle is the right hand end of the range. If we extend to np.inf then we ensure we have
probabilities that sum to 1. But that method introduces a probability mass in the last bucket that
is often not desirable (we expect to see a smooth continuous distribution and we get a mass). The
other alternative is to use endpoint = 1 bucket beyond the last, which avoids this problem but can leave
the probabilities short. We opt here for the latter and rescale</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sev_calc</strong> – continuous or discrete or raw (for…)</p></li>
<li><p><strong>discretization_calc</strong> – survival, distribution or both</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aggregate.distr.Aggregate.easy_update">
<code class="sig-name descname">easy_update</code><span class="sig-paren">(</span><em class="sig-param">log2=13</em>, <em class="sig-param">bs=0</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Aggregate.easy_update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Aggregate.easy_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function, delegates to update. Avoids having to pass xs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>log2</strong> – </p></li>
<li><p><strong>bs</strong> – </p></li>
<li><p><strong>kwargs</strong> – passed through to update</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aggregate.distr.Aggregate.emp_stats">
<code class="sig-name descname">emp_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Aggregate.emp_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Aggregate.emp_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>report_ser on empirical statistics_df - useful when investigating dh transformations.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aggregate.distr.Aggregate.json">
<code class="sig-name descname">json</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Aggregate.json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Aggregate.json" title="Permalink to this definition">¶</a></dt>
<dd><p>write in json
:return:</p>
</dd></dl>

<dl class="method">
<dt id="aggregate.distr.Aggregate.pdf">
<code class="sig-name descname">pdf</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Aggregate.pdf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Aggregate.pdf" title="Permalink to this definition">¶</a></dt>
<dd><p>probability density function, assuming a continuous approximation of the bucketed density
:param x:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="aggregate.distr.Aggregate.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param">kind='quick'</em>, <em class="sig-param">axiter=None</em>, <em class="sig-param">aspect=1</em>, <em class="sig-param">figsize=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Aggregate.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Aggregate.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>plot computed density and aggregate</p>
<p><strong>kind</strong> option:</p>
<ul class="simple">
<li><p>quick (default): Density for sev and agg on nominal and log scale; Lee diagram sev and agg</p></li>
<li><p>long: severity, log sev density, sev dist, agg with sev, agg on own, agg on log, S, Lee, return period</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kind</strong> – quick or long</p></li>
<li><p><strong>axiter</strong> – optional axiter object</p></li>
<li><p><strong>aspect</strong> – optional aspect ratio of individual plots</p></li>
<li><p><strong>figsize</strong> – optional overall figure size</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aggregate.distr.Aggregate.q">
<code class="sig-name descname">q</code><span class="sig-paren">(</span><em class="sig-param">p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Aggregate.q"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Aggregate.q" title="Permalink to this definition">¶</a></dt>
<dd><p>return lowest quantile, appropriate for discrete bucketing.
quantile guaranteed to be in the index
nearest does not work because you always want to pick rounding up</p>
<p>Definition 2.1 (Quantiles)
x(α) = qα(X) = inf{x ∈ R : P[X ≤ x] ≥ α} is the lower α-quantile of X
x(α) = qα(X) = inf{x ∈ R : P[X ≤ x] &gt; α} is the upper α-quantile of X.</p>
<p>We use the x-notation if the dependence on X is evident, otherwise the q-notion.
Acerbi and Tasche (2002)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aggregate.distr.Aggregate.recommend_bucket">
<code class="sig-name descname">recommend_bucket</code><span class="sig-paren">(</span><em class="sig-param">log2=10</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Aggregate.recommend_bucket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Aggregate.recommend_bucket" title="Permalink to this definition">¶</a></dt>
<dd><p>recommend a bucket size given 2**N buckets</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>log2</strong> – log2 of number of buckets. log2=10 is default.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aggregate.distr.Aggregate.report">
<code class="sig-name descname">report</code><span class="sig-paren">(</span><em class="sig-param">report_list='quick'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Aggregate.report"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Aggregate.report" title="Permalink to this definition">¶</a></dt>
<dd><p>statistics, quick or audit reports</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>report_list</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aggregate.distr.Aggregate.sf">
<code class="sig-name descname">sf</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Aggregate.sf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Aggregate.sf" title="Permalink to this definition">¶</a></dt>
<dd><p>return survival function using linear interpolation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – loss size</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aggregate.distr.Aggregate.tvar">
<code class="sig-name descname">tvar</code><span class="sig-paren">(</span><em class="sig-param">p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Aggregate.tvar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Aggregate.tvar" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the tail value at risk at threshold p</p>
<p>Definition 2.6 (Tail mean and Expected Shortfall)
Assume E[X−] &lt; ∞. Then
x¯(α) = TM_α(X) = α^{−1}E[X 1{X≤x(α)}] + x(α) (α − P[X ≤ x(α)])
is α-tail mean at level α the of X.
Acerbi and Tasche (2002)</p>
<p>We are interested in the right hand exceedence [?? note &gt; vs ≥]
α^{−1}E[X 1{X &gt; x(α)}] + x(α) (P[X ≤ x(α)] − α)</p>
<p>McNeil etc. p66-70 - this follows from def of ES as an integral
of the quantile function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aggregate.distr.Aggregate.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param">xs</em>, <em class="sig-param">padding=1</em>, <em class="sig-param">tilt_vector=None</em>, <em class="sig-param">approximation='exact'</em>, <em class="sig-param">sev_calc='discrete'</em>, <em class="sig-param">discretization_calc='survival'</em>, <em class="sig-param">force_severity=False</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Aggregate.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Aggregate.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the density</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> – range of x values used to discretize</p></li>
<li><p><strong>padding</strong> – for FFT calculation</p></li>
<li><p><strong>tilt_vector</strong> – </p></li>
<li><p><strong>approximation</strong> – exact = perform frequency / severity convolution using FFTs. slognorm or
sgamma apply shifted lognormal or shifted gamma approximations.</p></li>
<li><p><strong>sev_calc</strong> – discrete = suitable for fft, continuous = for rv_histogram cts version</p></li>
<li><p><strong>discretization_calc</strong> – use survival, distribution or both (=max(cdf, sf)) which is most accurate calc</p></li>
<li><p><strong>force_severity</strong> – make severities even if using approximation, for plotting</p></li>
<li><p><strong>verbose</strong> – make partial plots and return details of all moments by limit profile or
severity mixture component.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aggregate.distr.Aggregate.var">
<code class="sig-name descname">var</code><span class="sig-paren">(</span><em class="sig-param">p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aggregate/distr.html#Aggregate.var"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aggregate.distr.Aggregate.var" title="Permalink to this definition">¶</a></dt>
<dd><p>value at risk = alias for quantile function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Distribution Classes</a><ul>
<li><a class="reference internal" href="#frequency-class">Frequency Class</a></li>
<li><a class="reference internal" href="#severity-class">Severity Class</a></li>
<li><a class="reference internal" href="#aggregate-class">Aggregate Class</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="devel.html"
                        title="previous chapter">Development Outline</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="portfolio.html"
                        title="next chapter">Portfolio Class</a></p>
  <h3>This Page</h3>
  <div>
    <a href="_sources/aggregate.rst.txt"
       rel="nofollow">Show Source</a>
  </div>
<div class="this-page-menu">
  <a href="/scipy/docs/scipy-docs/aggregate.rst.rst">Edit page</a>
</div>

        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2018-19 Convex Risk LLC.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 2.2.1.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>